
// Grid Generator and Structure Script
// by Kyle Furey

using UnityEngine;

/// <summary>
/// Generates a mathematical grid using customizable variables.
/// </summary>
public class GridGenerator : MonoBehaviour
{
    [Header("Generates a mathematical grid using customizable variables.")]


    [Header("\nSETTINGS")]

    [Header("The 1 x 1 cube prefab used to generate the grid lines:")]
    public GameObject cubePrefab = null;

    [Header("Optional materials to represent the X, Y, and Z axes:")]
    public Material xAxisMaterial = null;
    public Material yAxisMaterial = null;
    public Material zAxisMaterial = null;

    [Header("The axis to generate the grid on (first is X, second is Y):")]
    public GridAxis generatedAxis = GridAxis.XZ;

    [Header("Whether to generate from the generator's position in just positive directions:")]
    public bool generatePositive = false;

    [Header("Grid square count:")]
    public Vector2Int count = new Vector2Int(10, 10);

    [Header("Whether to automatically include zero as its own column and row in the grid:")]
    public bool includeZero = true;

    [Header("Grid square size (scale applied to the cube prefab):")]
    public Vector2 size = new Vector2(1, 1);

    [Header("The thickness of each line (scale applied to the cube prefab):")]
    public float lineThickness = 0.05f;


    [Header("\nTESTING")]

    [Header("Whether to automatically generate a grid when the game starts:")]
    [SerializeField] private bool autoGenerate = true;

    [Header("Whether to enable live testing for grid generation:")]
    [SerializeField] private bool liveTesting = false;

    [Header("Test generation button:")]
    [SerializeField] private bool test = false;

    /// <summary>
    /// The current grid gameobject generated by this generator
    /// </summary>
    [HideInInspector] public GameObject generatedGrid = null;

    /// <summary>
    /// Grid axis enum
    /// </summary>
    public enum GridAxis { XZ, XY, ZY };


    // TESTING

    /// <summary>
    /// Generate on awake
    /// </summary>
    private void Awake()
    {
        if (autoGenerate)
        {
            GenerateGrid();
        }
    }

    /// <summary>
    /// Generate in editor
    /// </summary>
    private void OnValidate()
    {
        if (test)
        {
            test = false;

            Invoke("GenerateEditor", 0);
        }

        if (liveTesting)
        {
            Invoke("GenerateEditor", 0);
        }
    }

    /// <summary>
    /// Destroy the grid object and regenerate it
    /// </summary>
    private void GenerateEditor()
    {
        if (generatedGrid != null)
        {
            DestroyImmediate(generatedGrid);
        }

        GenerateGrid();
    }


    // GRID FUNCTIONS

    /// <summary>
    /// Logic for generating a grid
    /// </summary>
    /// <returns></returns>
    private GameObject Generate()
    {
        GameObject gridParent = new GameObject("Generated Grid");

        gridParent.transform.parent = transform;

        gridParent.transform.localPosition = Vector3.zero;
        gridParent.transform.localEulerAngles = Vector3.zero;
        gridParent.transform.localScale = Vector3.one;

        if (count.x < 0)
        {
            count.x *= -1;
        }

        if (count.y < 0)
        {
            count.y *= -1;
        }

        if (lineThickness < 0)
        {
            lineThickness *= -1;
        }

        int countX = includeZero ? count.x + 1 : count.x;
        int countY = includeZero ? count.y + 1 : count.y;

        for (int x = 0; x < countY + 1; x++)
        {
            GameObject line = Instantiate(cubePrefab);

            line.transform.parent = gridParent.transform;

            line.transform.localPosition = Vector3.zero;
            line.transform.localEulerAngles = Vector3.zero;
            line.transform.localScale = Vector3.one;

            line.GetComponent<Renderer>().material = selectref((int)generatedAxis, xAxisMaterial, xAxisMaterial, zAxisMaterial) == null ? line.GetComponent<Renderer>().material : selectref((int)generatedAxis, xAxisMaterial, xAxisMaterial, zAxisMaterial);

            line.transform.localPosition += x * size.y * selectref((int)generatedAxis, new Vector3(0, 0, 1), new Vector3(0, 1, 0), new Vector3(0, 1, 0));

            if (generatePositive)
            {
                line.transform.localPosition += countX * size.x * selectref((int)generatedAxis, new Vector3(1, 0, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)) / 2;
            }
            else
            {
                line.transform.localPosition -= countY * size.y * selectref((int)generatedAxis, new Vector3(0, 0, 1), new Vector3(0, 1, 0), new Vector3(0, 1, 0)) / 2;
            }

            line.transform.localScale = selectref((int)generatedAxis, new Vector3(countX * size.x, lineThickness, lineThickness), new Vector3(countX * size.x, lineThickness, lineThickness), new Vector3(lineThickness, lineThickness, countX * size.x));

            line.transform.localScale += selectref((int)generatedAxis, new Vector3(lineThickness, 0, 0), new Vector3(lineThickness, 0, 0), new Vector3(0, 0, lineThickness));
        }

        for (int y = 0; y < countX + 1; y++)
        {
            GameObject line = Instantiate(cubePrefab);

            line.transform.parent = gridParent.transform;

            line.transform.localPosition = Vector3.zero;
            line.transform.localEulerAngles = Vector3.zero;
            line.transform.localScale = Vector3.one;

            line.GetComponent<Renderer>().material = selectref((int)generatedAxis, zAxisMaterial, yAxisMaterial, yAxisMaterial) == null ? line.GetComponent<Renderer>().material : selectref((int)generatedAxis, zAxisMaterial, yAxisMaterial, yAxisMaterial);

            line.transform.localPosition += y * size.x * selectref((int)generatedAxis, new Vector3(1, 0, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1));

            if (generatePositive)
            {
                line.transform.localPosition += countY * size.y * selectref((int)generatedAxis, new Vector3(0, 0, 1), new Vector3(0, 1, 0), new Vector3(0, 1, 0)) / 2;
            }
            else
            {
                line.transform.localPosition -= countX * size.x * selectref((int)generatedAxis, new Vector3(1, 0, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)) / 2;
            }

            line.transform.localScale = selectref((int)generatedAxis, new Vector3(lineThickness, lineThickness, countY * size.y), new Vector3(lineThickness, countY * size.y, lineThickness), new Vector3(lineThickness, countY * size.y, lineThickness));

            line.transform.localScale += selectref((int)generatedAxis, new Vector3(0, 0, lineThickness), new Vector3(0, lineThickness, 0), new Vector3(0, lineThickness, 0));
        }

        return gridParent;
    }

    /// <summary>
    /// Generate a grid with the given variables
    /// </summary>
    /// <returns></returns>
    public GridGenerator GenerateGrid()
    {
        if (generatedGrid != null)
        {
            Destroy(generatedGrid);
        }

        if (cubePrefab == null)
        {
            return this;
        }

        generatedGrid = Generate();

        return this;
    }

    /// <summary>
    /// Detach the current grid from the generated grid
    /// </summary>
    /// <returns></returns>
    public GameObject DetachGrid()
    {
        GameObject grid = generatedGrid;

        if (grid != null)
        {
            generatedGrid = null;

            grid.transform.parent = null;
        }

        return grid;
    }

    /// <summary>
    /// Using the current settings, return the corresponding local position of the given world position relative to the grid.
    /// Does not require an actual grid to be generated; uses the settings of the grid generator.
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public Vector3 GetLocalPosition(Vector3 position)
    {
        position = transform.position - position;
        position = (position.x * transform.right + position.y * transform.up + position.z * transform.forward) * -1;
        position = new Vector3(position.x / transform.localScale.x, position.y / transform.localScale.y, position.z / transform.localScale.z);

        return position;
    }

    /// <summary>
    /// Using the current settings, return the corresponding world position of the given local position relative to the grid.
    /// Does not require an actual grid to be generated; uses the settings of the grid generator.
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public Vector3 GetWorldPosition(Vector3 position)
    {
        position += transform.position;
        position = (position.x * transform.right - position.y * transform.up - position.z * transform.forward) * -1;
        position = new Vector3(position.x * transform.localScale.x, position.y * transform.localScale.y, position.z * transform.localScale.z);

        return position;
    }

    /// <summary>
    /// Using the current settings, get the corresponding grid space of the given world position.
    /// Does not require an actual grid to be generated; uses the settings of the grid generator.
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public Vector2Int GetGridSpace(Vector3 position)
    {
        if (position.x < 0)
        {
            position.x -= 1;
        }

        if (position.y < 0)
        {
            position.y -= 1;
        }

        if (position.z < 0)
        {
            position.z -= 1;
        }

        position = GetLocalPosition(position);

        Vector2Int gridPosition = new Vector2Int();

        gridPosition.x = (int)selectref((int)generatedAxis,
            position.x / size.x,
            position.x / size.x,
            position.z / size.x);

        gridPosition.y = (int)selectref((int)generatedAxis,
            position.z / size.y,
            position.y / size.y,
            position.y / size.y);

        return gridPosition;
    }

    /// <summary>
    /// Using the current settings, get the corresponding grid space of the given world position and return if that position is inside the grid.
    /// Does not require an actual grid to be generated; uses the settings of the grid generator.
    /// </summary>
    /// <param name="position"></param>
    /// <param name="inGrid"></param>
    /// <returns></returns>
    public Vector2Int GetGridSpace(Vector3 position, out bool inGrid)
    {
        inGrid = InGrid(position);

        return GetGridSpace(position);
    }

    /// <summary>
    /// Using the current settings, check if the given position is inside the grid.
    /// Does not require an actual grid to be generated; uses the settings of the grid generator.
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public bool InGrid(Vector3 position)
    {
        position = GetLocalPosition(position);

        bool xIn;
        bool yIn;
        bool zIn;

        if (generatePositive)
        {
            xIn = selectref((int)generatedAxis,
                position.x >= 0 && position.x <= count.x * size.x,
                position.x >= 0 && position.x <= count.x * size.x,
                true);

            yIn = selectref((int)generatedAxis,
                true,
                position.y >= 0 && position.y <= count.y * size.y,
                position.y >= 0 && position.y <= count.y * size.y);

            zIn = selectref((int)generatedAxis,
                position.z >= 0 && position.z <= count.y * size.y,
                true,
                position.z >= 0 && position.z <= count.x * size.x);
        }
        else
        {
            xIn = selectref((int)generatedAxis,
                position.x >= count.x * size.x / -2 && position.x <= count.x * size.x / 2,
                position.x >= count.x * size.x / -2 && position.x <= count.x * size.x / 2,
                true);

            yIn = selectref((int)generatedAxis,
                true,
                position.y >= count.y * size.y / -2 && position.y <= count.y * size.y / 2,
                position.y >= count.y * size.y / -2 && position.y <= count.y * size.y / 2);

            zIn = selectref((int)generatedAxis,
                position.z >= count.y * size.y / -2 && position.z <= count.y * size.y / 2,
                true,
                position.z >= count.x * size.x / -2 && position.z <= count.x * size.x / 2);
        }

        return xIn && yIn && zIn;
    }

    /// <summary>
    /// Using the current settings, check if the given position is inside the grid and return the grid position of the given position.
    /// Does not require an actual grid to be generated; uses the settings of the grid generator.
    /// </summary>
    /// <param name="position"></param>
    /// <param name="gridPosition"></param>
    /// <returns></returns>
    public bool InGrid(Vector3 position, out Vector2Int gridPosition)
    {
        gridPosition = GetGridSpace(position);

        return InGrid(position);
    }

    /// <summary>
    /// Select from an integer and return the chosen data
    /// </summary>
    /// <typeparam name="DataType"></typeparam>
    /// <param name="n"></param>
    /// <param name="nData"></param>
    /// <returns></returns>
    private static ref DataType selectref<DataType>(int n, params DataType[] nData)
    {
        return ref nData[n];
    }
}

/// <summary>
/// A collection of variables representing an infinite mathematical grid.
/// </summary>
public struct Grid
{
    // VARIABLES

    /// <summary>
    /// The origin of this grid
    /// </summary>
    public Vector3 origin;

    /// <summary>
    /// The rotation of this grid
    /// </summary>
    public Quaternion rotation;

    /// <summary>
    /// The scale of this grid
    /// </summary>
    public Vector3 scale;

    /// <summary>
    /// Grid square size
    /// </summary>
    public Vector2 size;

    /// <summary>
    /// The axis this grid is on (first is X, second is Y)
    /// </summary>
    public GridAxis axis;

    /// <summary>
    /// Grid axis enum
    /// </summary>
    public enum GridAxis { XZ, XY, ZY };


    // CONSTRUCTORS

    /// <summary>
    /// Default constructor
    /// </summary>
    public Grid(object empty = null)
    {
        origin = Vector3.zero;
        rotation = Quaternion.identity;
        scale = Vector3.one;
        size = Vector2.one;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    public Grid(Vector3 origin)
    {
        this.origin = origin;
        rotation = Quaternion.identity;
        scale = Vector3.one;
        size = Vector2.one;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="rotation"></param>
    public Grid(Vector3 origin, Quaternion rotation)
    {
        this.origin = origin;
        this.rotation = rotation;
        scale = Vector3.one;
        size = Vector2.one;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="rotation"></param>
    /// <param name="scale"></param>
    public Grid(Vector3 origin, Quaternion rotation, Vector3 scale)
    {
        this.origin = origin;
        this.rotation = rotation;
        this.scale = scale;
        size = Vector2.one;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="rotation"></param>
    /// <param name="scale"></param>
    /// <param name="size"></param>
    public Grid(Vector3 origin, Quaternion rotation, Vector3 scale, Vector2 size)
    {
        this.origin = origin;
        this.rotation = rotation;
        this.scale = scale;
        this.size = size;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="rotation"></param>
    /// <param name="scale"></param>
    /// <param name="size"></param>
    /// <param name="axis"></param>
    public Grid(Vector3 origin, Quaternion rotation, Vector3 scale, Vector2 size, GridAxis axis)
    {
        this.origin = origin;
        this.rotation = rotation;
        this.scale = scale;
        this.size = size;
        this.axis = axis;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="eulerRotation"></param>
    public Grid(Vector3 origin, Vector3 eulerRotation)
    {
        this.origin = origin;
        rotation = Quaternion.Euler(eulerRotation);
        scale = Vector3.one;
        size = Vector2.one;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="eulerRotation"></param>
    /// <param name="scale"></param>
    public Grid(Vector3 origin, Vector3 eulerRotation, Vector3 scale)
    {
        this.origin = origin;
        rotation = Quaternion.Euler(eulerRotation);
        this.scale = scale;
        size = Vector2.one;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="eulerRotation"></param>
    /// <param name="scale"></param>
    /// <param name="size"></param>
    public Grid(Vector3 origin, Vector3 eulerRotation, Vector3 scale, Vector2 size)
    {
        this.origin = origin;
        rotation = Quaternion.Euler(eulerRotation);
        this.scale = scale;
        this.size = size;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="eulerRotation"></param>
    /// <param name="scale"></param>
    /// <param name="size"></param>
    /// <param name="axis"></param>
    public Grid(Vector3 origin, Vector3 eulerRotation, Vector3 scale, Vector2 size, GridAxis axis)
    {
        this.origin = origin;
        rotation = Quaternion.Euler(eulerRotation);
        this.scale = scale;
        this.size = size;
        this.axis = axis;
    }

    /// <summary>
    /// Copy constructor
    /// </summary>
    /// <param name="grid"></param>
    public Grid(Grid grid)
    {
        origin = grid.origin;
        rotation = grid.rotation;
        scale = grid.scale;
        size = grid.size;
        axis = grid.axis;
    }


    // FUNCTIONS

    /// <summary>
    /// Get a direction from the given euler rotation
    /// </summary>
    /// <param name="eulerRotation"></param>
    /// <returns></returns>
    private Vector3 GetDirection(Vector3 eulerRotation)
    {
        return rotation * eulerRotation;
    }

    /// <summary>
    /// Using the current settings, return the corresponding local position of the given world position relative to the grid
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public Vector3 GetLocalPosition(Vector3 position)
    {
        position = origin - position;
        position = (position.x * GetDirection(Vector3.right) + position.y * GetDirection(Vector3.up) + position.z * GetDirection(Vector3.forward)) * -1;
        position = new Vector3(position.x / scale.x, position.y / scale.y, position.z / scale.z);

        return position;
    }

    /// <summary>
    /// Using the current settings, return the corresponding world position of the given local position relative to the grid
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public Vector3 GetWorldPosition(Vector3 position)
    {
        position += origin;
        position = (position.x * GetDirection(Vector3.right) - position.y * GetDirection(Vector3.up) - position.z * GetDirection(Vector3.forward)) * -1;
        position = new Vector3(position.x * scale.x, position.y * scale.y, position.z * scale.z);

        return position;
    }

    /// <summary>
    /// Using the current settings, get the corresponding grid space of the given world position.
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public Vector2Int GetGridSpace(Vector3 position)
    {
        if (position.x < 0)
        {
            position.x -= 1;
        }

        if (position.y < 0)
        {
            position.y -= 1;
        }

        if (position.z < 0)
        {
            position.z -= 1;
        }

        position = GetLocalPosition(position);

        Vector2Int gridPosition = new Vector2Int();

        gridPosition.x = (int)selectref((int)axis,
        position.x / size.x,
            position.x / size.x,
            position.z / size.x);

        gridPosition.y = (int)selectref((int)axis,
            position.z / size.y,
            position.y / size.y,
            position.y / size.y);

        return gridPosition;
    }

    /// <summary>
    /// Select from an integer and return the chosen data
    /// </summary>
    /// <typeparam name="DataType"></typeparam>
    /// <param name="n"></param>
    /// <param name="nData"></param>
    /// <returns></returns>
    private static ref DataType selectref<DataType>(int n, params DataType[] nData)
    {
        return ref nData[n];
    }
}
